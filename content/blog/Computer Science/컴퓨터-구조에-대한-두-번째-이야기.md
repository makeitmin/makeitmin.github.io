---
title: 컴퓨터 구조에 대한 두 번째 이야기
date: 2021-07-17 18:07:70
category: Computer Science
thumbnail: { thumbnailSrc }
draft: false
---

## 컴퓨터 구조의 접근방법 (1)

### 컴퓨터 디자인

- CPU(하드웨어)를 디자인하는 것
- 하드웨어 전문가, 알고리즘 전문가, 인터페이스 전문가, 프로그래머 필요
- 명령어가 어떻게 구성되느냐에 따라 레지스터 구성되고, 레지스터 구성에 따라 하드웨어 디자인 
→ 하드웨어 디자인과 레지스터-명령어 디자인은 병행 필요
- **레지스터**와 **명령어**(컴파일러를 통해 만들어지는 명령어의 집합) 디자인

### 레지스터 디자인의 핵심

- 레지스터의 비트 수
→ 보편적으로 n비트 시스템에서는 명령어가 n비트이기 때문에 레지스터도 n비트로 설정
- 레지스터 개수
→ 다다익선
- 레지스터 각각의 용도
→ RAM이나 H/D과 같은 범용 메모리와는 다르게 특별한 목적이 할당된 칸이 존재
→ 명령어가 단순화되고, 속도 향상

## 컴퓨터 구조의 접근방법 (2)

명령어 디자인에 따라 ALU 도 결정 → ALU가 명령어를 읽어야 하기 때문

### 명령어 구성

각 부분에 비트를 조합하여 할당 → 명령어의 종류에 따라 명령어 구성(설계)이 상이

- 예약
- 연산자
- 저장소
→ 연산 결과는 레지스터에 저장
- 피연산자
→ 레지스터 주소 or 숫자 구분하기 위해 첫 비트를 구분자로 약속
→ 표현할 수 있는 숫자가 많지 않음

### 명령어 구조 종류

- CISC 계열
→ 복잡한 명령어, 다양한 형태로 조합
→ 일정 수준 이상 속도를 향상시킬 수 없음
- RISC 계열
→ CISC의 명령어를 간소화
→ 제한사항 존재
→ 오늘날 대부분의 CPU에 적용
→ Fetch, Decode, Execution 을 각각 1클럭에 수행할 때, 여러 명령어 동시에 실행 가능
→ CISC 보다 적은 클럭 수를 가지고 같은 양의 명령 수행 가능

## LOAD & STORE 명령어 디자인

### LOAD 명령어

- 레지스터로 피연산자의 메모리 주소를 불러들이는 명령
- 명령어 구조
→ 예약
→ LOAD
→ destination
→ source

### STORE 명령어

- 연산 결과를 레지스터에 저장
- 명령어 구조
→ 예약
→ STORE
→ source
→ destination

### LOAD 와 STORE 의 필요성

- 명령어 제한
→ 사칙연산의 피연산자는 숫자 or 레지스터 주소
→ 연산 결과는 레지스터에 저장
→ 모든 연산은 레지스터를 통해 진행

### 레지스터를 통한 연산

**LOAD r1, 0x10** (0x10 에 있는 피연산자 호출하여 r1에 할당)  
**LOAD r2, 0x20** (0x20 에 있는 피연산자 호출하여 r2에 할당)  
  
**ADD r3, r1, r2** (r1 과 r2 를 ADD 연산 하여 r3 에 할당)  
  
**STORE r3, 0x30** (r3 의 값을 0x30 에 저장)

## 메모리를 참조하는 방법

### Direct 모드

- 메모리 주소를 레지스터에 바로 할당
→ LOAD r1, 0x10 (0x10 값을 r1 에 할당)

### Indirect 모드

- 메모리 주소에 있는 번지수를 참조하여 해당 번지에 있는 값을 레지스터에 할당
→ LOAD r1, [0x10] (0x10 에 있는 번지수를 참조하여 그 값을 r1 에 할당)

### 문제점

- 현재의 비트 수로는 주소나 값을 표현하기 어려움

### 해결법

**LOAD r1, 0x0010** (0x0010 에 있는 피연산자 호출하여 r1에 할당)  
  
**MUL r0, 4, 4** (4와 4를 곱셈하여 16을 r0에 할당)  
**MUL r2, 4, 4** (4와 4를 곱셈하여 16을 r2에 할당)  
**MUL r3, r0, r2** (r0와 r2를 곱셈하여 256, 즉 0x100 을 r3에 할당)  
  
**STORE r3, 0x0030** (r3 의 값을 0x0030 에 저장)  
**LOAD r2, [0x0030]** (0x0030 에 있는 번지수를 참조하여 그 값을 r2 에 할당)  
  
**ADD r3, r1, r2**
