---
title: Django 시작하기 (feat. PostgreSQL)
date: 2021-08-03 12:08:42
category: TIL
thumbnail: { thumbnailSrc }
draft: false
---

이때까지 사용해본 웹 프레임워크는 **Spring**과 **Flask**가 있었다. Spring은 Java를 사용하던 3학년 때 전자정부표준프레임워크(eGovFrame)을 사용했던 경험으로 알고 있었고, Flask는 지난 6개월 간 엘리스 AI 트랙에서 수행한 프로젝트에서 백엔드 프레임워크로 사용하며 경험하였다.

Spring은 MVC 패턴을 따르는 프레임워크로, 데이터를 관리하는 부분(Model)과 HTTP 요청을 처리하는 부분(View)과 라우팅 부분(Controller)로 이루어져 있었다. 사실 그때는 MVC 패턴의 장점인 재사용성, 모듈화 등을 정확히 알고 썼다기보다는 폴더가 역할별로 잘 나뉘어 있기 때문에 화면 코드(JSP, HTML)와 데이터를 불러오는 코드(DAO: Data Access Object)가 어지럽게 뒤섞이지 않는 것이 좋았던 것 같다.

Flask는 Python 환경에서 Flask 패키지를 설치해서 `app.py` 파일 하나에 API 함수를 짜서 하나하나 조립하듯이 구현했기 때문에 직관적이고 자유도가 높아서 좋았다.

이렇게 지금까지 알고 있던 2개의 프레임워크를 뒤로 하고, Python으로 백엔드를 구현할 때 가장 많이 사용한다는 Django에 대해 알아보려고 한다.

## Django 조사하기

Django에 대해 다룬 블로그나 문서는 아주 많았다. 처음부터 전부 알기엔 어려웠지만, 내 머리는 이때까지의 경험에 빗대어 Django를 이렇게 (아주 거칠게) 요약했다. 

**Spring의 MVC 패턴을 가져가면서 Flask처럼 Python을 사용하는 프레임워크**

MVC 패턴에서의 Controller 역할을 Django에서는 프레임워크 자체가 수행하기 때문에 Controller보다는 화면을 보여주는 Template 부분을 강조하여 MVT, MTV 패턴으로 표기한 곳도 많았다.

Python을 쓰는 Flask와의 비교도 많이 볼 수 있었다. 

Django는 구현해야 하는 내부 앱이 많거나, 안정성과 확장성을 중요하게 여기는 대형 프로젝트에서 사용한다. Django로 프로젝트를 생성하면 대부분의 개발환경 설정이 완료되어 있기 때문에 경제적이다. 

반면 Flask는 복잡한 구조가 필요하지 않고, 안정성을 개발자가 짠 코드만으로도 충분히 커버할 수 있는 간단한 프로젝트에서 많이 사용한다. 당연히 Django보다 가볍다.

## Django 프로젝트

### Django 설치

여러 글을 읽었는데 일단 너무 많고, 나는 글로 읽는 것보다 직접 해보면서 더 잘 배우는 타입이어서 그냥 Django 프로젝트를 하나 만들어보기로 했다.

1. django 패키지를 설치한다.

    ```bash
    pip install django
    ```

2. django_test라는 이름의 프로젝트를 생성한다.

    ```bash
    django-admin startproject django_test .
    ```

3. 프로젝트 Tree는 다음과 같다. 참고로 Linux 환경에서는 `tree` 명령어를 이용하면 손쉽게 폴더 구조를 그릴 수 있다.  

    ```bash
    django_test
    |-- django_test
    |   |-- __init__.py
    |   |-- asgi.py
    |   |-- settings.py
    |   |-- urls.py
    |   `-- wsgi.py
    `-- manage.py
    ```

### 생성된 파일의 용도

자동으로 생성된 각각의 파일이 어떤 역할을 하는지 알아보았다.

- **manage.py**

	Django 프로젝트의 다양한 커맨드를 관리하는 Util 파일

- **__init__.py**

	Python이 이 디렉토리를 패키지처럼 다룰 수 있도록 명시하는 파일

- **settings.py**

	Django 프로젝트의 환경 및 구성을 저장하는 파일

- **urls.py**

	Django 프로젝트의 URL 선언을 저장하는 파일

- **asgi.py**

	Django 프로젝트를 서비스하기 위한 ASGI 호환 웹 서버 인터페이스

- **wsgi.py**

	Django 프로젝트를 서비스하기 위한 WSGI 호환 웹 서버 인터페이스

### WSGI와 ASGI의 차이점

생성된 파일을 보면, 웹 서버 인터페이스를 담당하는 파일이 wsgi.py와 asgi.py로 2개인 것을 확인할 수 있다. 애플리케이션이 Nginx, Apache와 같은 웹 서버와 상호작용하기 위한 인터페이스라는 점에서는 같은 역할을 하지만, 각각 호환되는 형식에 따라 나뉜 것이다.

그렇다면 이 2가지 형식의 차이는 무엇일까? 가장 큰 차이점은 **비동기 처리의 가능 여부**에 있다.

- **WSGI**

    웹 서버와 애플리케이션 사이의 미들웨어로 웹 서버가 애플리케이션의 코드를 이해할 수 있도록 중간에서 코드를 읽어 반환하는 역할이다. WSGI는 2가지 형태가 존재한다.
    - 웹서버(Nginx, Apache)에서 제공하는 내장 모듈 형식
	- Python으로 작성된 Web App Server 형식

- **ASGI**

    대용량 트래픽에서 동기 처리만을 지원하여 한계를 가지는 WSGI와는 달리, ASGI는 비동기 처리를 지원한다. 따라서 **Websocket 프로토콜과 HTTP 2.0을 지원**한다고 한다. Websocket 등을 사용한 **실시간 서비스** 등에는 ASGI가 적합하다.

### PostSQL 데이터베이스에 유저 등록하기

1. PostgreSQL은 사전에 설치한 상태이다. 다음과 같이 입력하여 접속한다.

    ```bash
    sudo -u postgres psql
    ```

2. 접속에 성공하면 유저를 생성한다. 'admin'이라는 이름으로 생성했다.

    ```bash
    CREATE USER admin;
    ```

3. 프로젝트에 쓸 데이터베이스를 생성한다.

    ```bash
    CREATE DATABASE django_db OWNER admin;
    ```

4. 참고로 유저 패스워드는 다음과 같이 변경할 수 있다.

    ```bash
    ALTER USER admin WITH PASSWORD 'admin';
    ```

### PostgreSQL 패키지 설치하기

pip로 PostgreSQL 패키지를 설치한다.

```bash
pip3 install psycopg2
```

설치하는 중에 다음과 같은 오류가 발생하였다.

```bash
...
./psycopg/psycopg.h:36:10: fatal error: libpq-fe.h: No such file or directory
...
error: command 'x86_64-linux-gnu-gcc' failed with exit status 1
```

`libpq` 패키지를 따로 설치하고 다시 시도하면 된다.

```bash
sudo apt-get install libpq-dev
```

### 프로젝트 설정(settings.py) 수정하기

Django 프로젝트의 설정이 구현되어 있는 `settings.py` 파일을 다음과 같이 수정한다. 데이터베이스로 설정한 PostgreSQL은 사전에 설치한 상태이다.

- 시간대(TIME_ZONE)
- static 폴더의 경로(STATIC_ROOT)
- 데이터베이스 설정(DATABASES)

```python
"""
Django settings for django_test project.

Generated by 'django-admin startproject' using Django 3.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.2/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-#x(fox4#*2+x(c%v!jmf(7om$xw)_9qx0y^&efx6i9_b)9fv+d'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'django_test.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'django_test.wsgi.application'

# Database
# https://docs.djangoproject.com/en/3.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'django_db',
        'USER': 'admin',
        'PASSWORD': 'admin',
        'HOST': 'localhost'
        'PORT': '5432',
    }
}

# Password validation
# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
# https://docs.djangoproject.com/en/3.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'Asia/Seoul'

USE_I18N = True

USE_L10N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.2/howto/static-files/

STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

# Default primary key field type
# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
```

## Django App 작성하기

다음 명령어를 통해 프로젝트 내부에 기능 별로 App을 작성할 수 있다.

```bash
python3 manage.py startapp example_app
```

디렉토리 구조는 다음과 같이 바뀐다.

```bash
django_test
    |-- django_test
    |   |-- __init__.py
    |   |-- asgi.py
    |   |-- settings.py
    |   |-- urls.py
    |   `-- wsgi.py
    |-- example_app
    |   |-- __init__.py
    |   |-- admin.py
    |   |-- apps.py
    |   |-- migrations
    |   |-- models.py
    |   |-- tests.py
    |   |-- views.py
    `-- manage.py
```

## Django + PostgreSQL 연동하기

생성하고자 하는 데이터베이스를 ```models.py``` 에 작성한 후, Django 프로젝트에 데이터베이스가 반영될 수 있도록 마이그레이션 작업을 해준다.

```bash
# 마이그레이트
python3 manage.py makemigration
python3 manage.py migrate

# 슈퍼유저 생성
python manage.py createsuperuser
```

## Django 서버 실행하기

### DEBUG 옵션 수정하기

Django 서버를 실행하기에 앞서, ```settings.py```에서 ```DEBUG``` 옵션을 ```True```로 설정해야 한다. 이는 배포용이 아닌 개발용으로 사용하겠다는 의미이다.

```python
# settings.py
...
DEBUG = True
...
```

```DEBUG``` 옵션이 ```True```인 상태에서는 ```static``` 폴더에 있는 정적 파일(이미지, CSS 등)이 기본적으로 지원된다.
```DEBUG``` 옵션이 ```False```이면 웹 서버에서 을 지원하도록 개발자가 따로 설정해야 CSS 등이 적용된 화면이 제대로 출력된다.

### 서버 실행하기

설정을 마치면 다음 명령어로 Django 서버를 실행한다.

```bash
python3 manage.py runserver
```

## 참고자료

- Django 초보 가이드 - 실습을 통해 알아보는 장고 입문 ([강의](https://www.inflearn.com/course/django-%EC%B4%88%EB%B3%B4-%EA%B0%80%EC%9D%B4%EB%93%9C-%EC%8B%A4%EC%8A%B5%EC%9D%84-%ED%86%B5%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%EC%9E%A5%EA%B3%A0-%EC%9E%85%EB%AC%B8))
- Django 공식 문서 (문서)
    - Django 앱 작성하기 ([문서](https://docs.djangoproject.com/ko/3.2/intro/tutorial01/))
    - ASGI를 사용하여 배포하는 방법 ([문서](https://docs.djangoproject.com/ko/3.2/howto/deployment/asgi/))
- Django Girls 튜토리얼
    - 나의 첫 번째 Django 프로젝트 ([블로그](https://tutorial.djangogirls.org/ko/django_start_project/))
    - PostgreSQL 연동 준비 ([블로그](https://tutorial-extensions.djangogirls.org/ko/optional_postgresql_installation#undefined-6))
- REST API 개발로 알아보는 WSGI, ASGI ([블로그](https://blog.neonkid.xyz/249))
- psycopg2 설치 오류 ([문서](https://stackoverflow.com/questions/63584368/pip-install-psycopg2-error-command-x86-64-linux-gnu-gcc-failed-with-exit-st))
- DEBUG=False 이면 static 파일에 접근이 안 되는 이유 ([문서](https://stackoverflow.com/questions/5836674/why-does-debug-false-setting-make-my-django-static-files-access-fail))
- PostgreSQL 연동하기 ([블로그](https://hecpas0620.tistory.com/15))
